IDE  - 编辑器
JS核心 - CMAScript  - ES

五种简单
Undefined -未定义
Null = 空
Boolean = 布尔值
Number = 数
String = 字符串
复杂
Object - 对象

_1.(x < 10 && y > 1) 为 true
JavaScript中&&的处理规则是这样的：
1.判断第一个值是否为False。如果为False，则直接返回第一个值(不一定为boolean类型)。
2.如果第一个值为True，则直接返回第二个值(不一定为boolean类型)。

_2.变量提升
consol.log(a)  undefine
consol.log(b)  未声明
var a=0   var会触发变量提升  提升到最顶部 作为全局变量
window.b =1 b=1  不会触发变量提升

只有var定义，变量才会有变量提升。
var a和a在浏览器环境下都是在window上定义a属性
<script type="text/javascript">
		
		console.log(a)  undefined
		console.log(b)  b is not defined
		var a =0
		b = 0
</script>

逻辑或||的处理规则
1.判断第一个值是否为True。如果为True，则直接返回第一个值(不一定为boolean类型)。
2.如果第一个值为False，则直接返回第二个值(不一定为boolean类型)。

Undefined -未定义
比如var a；  a是个undefined
<script type="text/javascript" src="vue.min.js">
	var a;
	typeof a;//返回数据类型

	window 是全局的

		console.log(window.innerWidth);
		console.log(window.innerHeight);屏幕可视长度
		//screenLeft\Top 屏幕距离 

延时定时器 只执行一次
window.setTimeout(函数名,ms)  也可以直接把函数写进去

轮循定时器 不会停
window.setInterval()
window.clearInterval() 关闭

var t = setInterval(a,1000);
clearInterval(t); 

打开网页
open("http://www.baidu.com");
close();
setTimeout(function(){close()},3000);//3秒后关闭

this 是window
self  top

& | 位运算 比加减乘除优先级还低  化成二进制 或 与

小数计算有Bug

string ＋ 任何东西都是string
       - 数字 = 数字
       如果结果不是数字 =NaN

'abc'[0] = 'a';

.substring(n1,n2)    'abcd' '0 a 1 b 2 c 3 d 4'
一个参数就从头剪到尾
.toUpperCase()变大写
.toLowerCase()变小写
 
'abc'.concat('def') 字符串拼接   .concat('def').concat('def').concat('def') 可以这样写
'abc'.replace('c','k') 只能换最前面那个c
'abc'.indexOf('b')  返回第一个出现b的下标  也可查字符串'bc'  没找到-1

DOM -> Document Object Model 文档对象模型

onload事件 页面刚开始运行时触发的事件
onload = function(){

			document.getElementById('mydiv').style.width = '500px';
		}
 
 onclick 鼠标选中事件  按钮显示隐藏例子
var flag =0;
	var t = document.getElementById(
		'mydiv');
	var btn = document.getElementById('mybt')
	btn.onclick = function()
	{
		if(flag == 0)
		{
			t.style.display = 'none';
			flag=1;
		}
		else
		{
			t.style.display = 'block';
			flag=0;
		}

	}

var t = document.getElementsByTagName('div');
		t[0].style.cssText = 'background-color:red;width:200px;height:300px;' 下标给

t[0].className 返回他的类名
t[0].className = 'classs2' 改变类名

t.innerHTML='' 改变标签里面的内容

document.getElementsByClassName('div')
document.getElementsByTagName('div')  标签名 通过下标来给样式 
document.getElementById('mybt')       通过ID

交互：
var a = document.getElement...
a.onmouseover = function(){...}  鼠标移入
a.onmouseout = function(){...}   鼠标移出
onmousemove 鼠标移动
onmousedown 鼠标按下
onmouseup 鼠标抬起
oncontextmenu 右键事件

tt.onmousedown = function(){
	return false; 让选中失灵，取消默认事件
}

鼠标事件对象
event.clientX  //         →x
event.clientY //鼠标坐标轴↓y

window.onresize = function(){}  浏览器窗口大小改变

闭包
：子函数使用父函数的行为叫做闭包
子函数可以用父类的局部变量  父类不能用子函数的局部变量

生命周期：
var a = 10;如果后面没有用到，就死了。即最后一次使用后就杀死

将赋予另一个变量，可以延长生命周期，若想永恒，则 window.b = a;

回收机制：
var a=10;a=null;即手动回收

去小数点后面方法
1.var a = Math.random();
				a =  (a*1000)%256;
				a -= a%1;

2.parseInt(a);

new Vue({
	el:'选择器'，作用域
	data:{
		输出的内容
	}
})

v-show
<div v-show='false'></div> 使元素不显示

</script>

<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>						 	 索引值
	<div v-for='i in arr'>{{i}}{{$index}}</div>  v-for使用方法
	<script type="text/javascript">
		new Vue({
			el:'body',
			data:{
				arr:{'a','b','c'}
			}
		})
	</script>					键	  值
	<div v-for="i in jason">{{$key}}{{i}}</div>
	<script>
			new Vue({
				el:'body',
				data:{
					msg:'fuck',
					jason:{
						name:'shabi',
						age:'18'
					}
				}
			}
			)
		</script>

	v-model 双向绑定

</body>
</html>


	<body>      //另一种写法 @click'test'
		<button v-on:click="test" class="bt">显示|隐藏</button>
		<div v-show="mm"></div>
		<script type="text/javascript">
			new Vue({
				el:'body',
				data:{
					mm:true
				},
				methods:{
					test:function(){
						this.mm = !this.mm;  this是data的指针
					}
				}
			})
		</script>
	</body>


科学计数法
5e4 = 50000

字符串加上任何数都会变成字符串
除加法之外字符串会变成数字

字符串比较大小只看第一位
'5' >'42'

数字与字符串比较会触发隐式转换成数字
'5' > 4

=== 三个等号 绝对等于 需要数据类型都一样

divname.innerHTML = '..' 让divname显示

boolean对象返回false：空字符串 0 null undefined false NaN
null在计算中当成0处理
undefined计算都是undefined

document.参数
title 网页标题
URL  此文件地址
domain 第一层域名1
write(...)清空网页写入...并且会叠加

window.onload = function(){}页面加载后执行此函数

1.document操作元素例子
<script type="text/javascript">
	
	window.onload = function(){
		document.body.style.background = 'red';
	}因为body在下面 没执行完 需要onload才能找到
	带有-的使用驼峰命名法，使用大写。
	document.body.style.backgroundColor = 
	document.getElementById('元素id')
	document.getElementsByClassName('')


	2.操作按钮
	document.getElementById('btid').onclick = function(){
		操作内容
	}

</script>

2.获取元素id或类
<script type="text/javascript">
	var a = document.getElementById('ts')
	a.id
	a.className
</script>
<div class = 'aaa bbb ccc'></div>可通过空格赋值多个类名

3.获取元素名
<script type="text/javascript">
	var a = document.getElementById('ts')
	
	a.onclick = function(){
		alert(this.noneName);  
	}

</script>
自定义标签都是行内元素，不能是中文 数字

4.操作input里的内容
<script type="text/javascript">
	var a = document.getElementById('ts')

	a.value  #123  返回的是字符串
	a.value = 2;赋值

</script>

5.元素改变内容
<script type="text/javascript">
	var t = document.getElementById('ts')

	t.onchange = function(){} 内容改变且焦点消失会触发 如12 改成12内容没有改变不会触发
	t.oninput = function(){} 只要在里面输出就触发
</script>

<input type="button" name="" id="ts" value="123" maxlength="5">
6.input的几种属性
text   number:点击加减数字  button  range:滑条  color


7.if-else语句
<script type="text/javascript">
	if(){

	}
	else if(){

	}
	else
	{
		
	}

</script>

8.JS操作元素里的内容
<div id="tt"></div>
<script type="text/javascript">
	

	id.innerHTML  里面内容 或者元素都可以获取
	也可以赋值
	tt.innerHTML = 1
	tt.innerHTML += '<div class="fuck"></div>'; 单引号里面要用双引号
	
	重新替换元素会使原本的事件消失
	tt.innerHTML = '<div id="tt"></div>'

	id.innerText 略过标签 只读取本文
	赋值标签时 会当成文本处理

	id.outerHtml 获取包含自己的DOM内容


</script>

9.js快速赋值样式
<script type="text/javascript">
	
	tt.style.cssText = 'css的内容'
</script>



10.获取非行间样式值  和行间  删除
<style type="text/css">
	.aa{此处的为非行间样式值}
</style>

<div class="aa"  abc='123' style="width: 200px"></div>  abc为自定义的行间属性
<script type="text/javascript">
	window.getComputedStyle(leo).width; 支持IE8以上
	tt.currentStyle.width;  谷歌不认

	if(tt.currentStyle.width){    兼容

	}
	else{
		getComputedStyle(leo).width;
	}

	aa.style.width 非自定义的可以直接获取  (要在行间内)
	aa.class

	aa.getAttribute('abc')  自定义的行间属性需这样获取
	aa.setAttribute('www','123') 自定义设置行间属性  

	aa.removeAttribute('bb') 若删除id 则直接调用id的会报错 除非已经用var id = document.getElementById保存

	aa.hasAtrribute('aa') 判断是否存在行间属性aa 若存在返回ture 

</script>

11.switch
<script type="text/javascript">
	var a=5;
			switch(a){
				case 5:alert('fuck5');
				case 1:alert('fuck');
				case 2:alert('fuck2');
				case 3:alert('fuck3');
				
			}

	case不加break语句会从匹配的位置一直往下执行
</script>

12.获取父级元素 子集  生成元素 删除子元素
<script type="text/javascript">
	
	tt.parentNode
	tt.children 获取子元素

	tt.childNode 获取子元素 加文本 

	使用tt.childNode[0].data = ...更改里面文r本元素 换行、空格也算元素 

    var a =  document.createElement('div') 生成一个div

    tt.appendChild(a) 将a放进tt里的最后面 若元素已经存在 则会将元素移动 

    tt.insertBefore(a,tt.children[0]) 将a放在tt第一个子元素前面

    tt.removeChild(tt.children[0]) 删除tt的第一个子元素

</script>

13.替换元素
	<ul id='hh'>
		<li>111</li>
		<li>222</li>
		<li>333</li>
	</ul>
			
	<ul id='gg'>
		<li>444</li>
		<li>555</li>
		<li>666</li>
	</ul>
<script type="text/javascript">
	hh.replaceChild(gg.children[0],hh.children[0])
	gg.children[0]会被取出然后替换掉 hh.children[0]
</script>


14.克隆元素
<script type="text/javascript">
	var a = gg.children[0].childNode()   #原元素不变 传参为true时里面的内容也克隆过去
										 事件不会克隆
	hh.appendChild(a)
</script>


15.首尾元素 兄弟元素
<script type="text/javascript">
	a.firstElementChild  与 a.children[0] 相同
	a.lastElementChild 最后的元素

	a.nextElementSibling a的下一个元素
	a.previousElementSibling a的上一个元素
</script>


16.鼠标事件
<script type="text/javascript">
	
	return false 会把原来的默认事件去掉
	hh.ondblclick = function(){return false}鼠标双击事件

	hh.onmouseover = function(){}  鼠标移入事件

	hh.onmouseenter 移入事件

	hh.onmouseleave = function(){} 鼠标移出事件

	hh.onmouseout = function(){}   鼠标移出事件 移到此元素里面的元素上也算

	hh.onmousemove = function(){} 在hh元素上移动触发事件

	hh.onmousedown = function(){} 鼠标按下事件  注意：onclick 比 Up 慢
	
	hh.onmouseup = function(){} 鼠标弹起事件

右键:

	hh.oncontextmenu = function(){}


</script>

17.事件对象 
每个事件里都会有许多有用的对象
<script type="text/javascript">
	
	hh.onclick = function(){
		例如：
		event.clientX  横坐标
		event.target 	事件名

	}

</script>

18.阻止事件冒泡
<script type="text/javascript">
	
	hh.onclick = function(){
		event.cancelBubble = true 阻止事件冒泡
		event.stopPropagation() 兼容性较低

	}

</script>

19.焦点事件
<input type="" name="" id='jd' autofocus>  打开网页时自动获取焦点
<script type="text/javascript">
	
	jd.onfocus = function(){  焦点事件
		
		hh.focus(); 让hh获得焦点
	}

	jd.onblur = function(){  失去焦点事件
		gg.blur()让gg失去焦点
	}

页面只能存在一个焦点
</script>

20.可见宽度高度

<script type="text/javascript">
	
	tt.offsetWidth
	tt.offsetHeight

	tt.clientWidth  与off区别（不计算border的值）


	注意： offsetWidth 是数字 无px 要加'px'

	tt.style.width 带单位 有'px'

</script>

21.元素偏移距离属性
<script type="text/javascript">
	
	tt.offsetLeft    父类没定位 则输出与浏览器边框的距离  
	tt.offsetTop	 父类有定位 输出与父类的距离

	clientLeft  边框造成的偏移
	clientTop
</script>

22.元素拖拽效果
<script type="text/javascript">
			
			fuck(bb)
			
			function fuck(tt){
				
				tt.onmousedown = function(){
					var dex = event.clientX - this.offsetLeft;
					var dey = event.clientY - this.offsetTop;
					var _this = this;
					
					document.onmousemove = function(){
						_this.style.left = event.clientX -dex +'px'
						_this.style.top = event.clientY -dey +'px'
					}
					
					document.onmouseup = function()
					{
						this.onmousemove = null
						this.onmouseup = null
					}
					return false
					
				}
				
			}
</script>

23.数组
<script type="text/javascript">
	
	1. var arr = [1,2,null,'aaw',function(){alert(1)}]

	访问函数 arr[4]()

	2. var arr2 = Array(1,2,3,4)

	3. var arr3 = new Array(1,true,3,4,5)

</script>

24.字符串拼接 变大小写  

<script type="text/javascript">
	str ='abc'

	str.substring(a,b)
	//从光标a后 截取到光标前b
	如过b是0或负数，则从第0位截取到a的位置
	str.substring(a)
	从光标a截取到最后面

	str.substr(a,b)
	从第a位开始截取，截取b位
    str.substr(a）
    从光标a截取到最后面 a位负数则从尾巴前数，截b位

    str.slice(a,b)
    b是负数  从a开始  截到尾巴数起b位

    str.toUpperCase() 变大写
    str.toLowerCase() 变小写

    从前找
    str.indexOf('b') 返回第一个出现b的下标  没找到-1
    str.indexOf('b',1) 从第一位开始找 
    str.indexOf('bc')

    从后找
    str.lastIndexOf('b')
    str.lastIndexOf('b',5) 截取5位 从后找 

    替换元素
    str.replace('a','b') 从前找到的第一个a改成b
    str.replaceALL('a','b') 全部

     str.replace / ALL ('c',function(text,index,lastStr){
     	text:要找到
     	index 下标
     	lastStr: str
     })

     去掉空格

     str.trim() 清除前后空格
     str.trimLeft()  .trimStart() 清除最左边空格
     str.trimRight()  .trimEnd() 右边

</script>

25.字符串切割成数组 split
<script type="text/javascript">
	var str = 'absddsffesgqwe'
    var str1 = 'abc' 
	str.split('s')  ['ab','dd','ffe','gqwe']
	str1.split('') ['a','b','c']
	str.split('s',2)  ['ab','dd']

</script>

26.数组操作
<script type="text/javascript">
	
	26.1字符串插入
	var arr = [1,2,3],arr2 =[4,5,6]
	arr.push(4) 尾部插入4  返回值是数组的长度
	arr.push(4,5,6) 批量插入
	arr.unshift()  头部插入内容

	arr.pop() 尾部删除元素，返回删除的内容   无参数
	arr.shift() 头部删除元素

	26.2字符串拼接
	返回值是个新数组 不会改变arr arr2
	arr.concat(arr2)
	arr.concat(arr2,[12,3,2],true,window) 批量插入

	26.3索引
	arr.indexOf(2)  =1  找不到返回-1  和字符串的基本相同 第二参数为从第几个开始找
	arr.lastIndexOf(2) 从后找  第二个参数从前截取几位后 找
 	
 	26.4数组倒序
 	arr.reverse()
 	字符串可先通过split转成数组 在倒序

 	26.5数组转字符串
 	将数组里的,替换
 	arr.join()  '1,2,3'
 	arr.join('')  '123'
 	arr.join('awe')  '1awe2awe3'

 	26.6截取数组
 	arr.slice(1,3) 从第一位截取到第三位 返回新的数组
 	只传一个参数则从参数截取到尾
 	arr.slice(a,-b) 从a开始截取到 从尾部数第b位

 	26.7数组排序
 	arr.sort()    a.charCodeAt() 根据这个码来排序

 	arr.sort(function(a,b){return a-b}) 自定义排序 从小到大  b-a 从大到小
 
</script>


27.查看类的方法
<script type="text/javascript">
	String.prototype

	String.prototype.fun = function(){} 修改|添加类的方法

	function lei(){

	};

	lei.prototype = {  创建一个类
		'aa':function(){

		},
		'bb':function(){

		}
	}

	new lei().aa();

</script>

28.let
不会触发变量提升
不能重复声明
会形成块级作用域 当时传进来是什么就是什么
<script type="text/javascript">

		for属于同步任务  setTimeout属于异步任务 
		同步任务执行完才会执行异步任务 若这里用var的话 执行setTimeout 里面的i是10 整个i是在外面的
		let使得i在次形成了块级作用域 
		for(let i=0;i<10;i++){
		        setTimeout(function(){
		         console.log(i);  
		        },5000);
		}

</script>

29.const
必须有初始化的值 而且不能被覆盖和重复声明  但可以改他里面的属性
const支持块级作用域并且和let不能被变量提升 
如果const的内容为对象 可以修改里面的属性
<script type="text/javascript">
	const a=1
	a=2 //报错
	const b = {a:1}
	b.a =4  //通过
	
	{
		const c=4
	}
	console.log(c) //报错

</script>

30.箭头函数  不能用arguments 没有变量提升
！！！！注意 一定要习惯加分号 否则会出现一些奇奇怪怪的问题

箭头函数、没有prototype、没有自己的this指向、不可以使用arguments、自然不可以new
所以箭头函数里的this相当于上一层的this
<script type="text/javascript">
	格式
	函数名=参数=>返回值
	
	tts=r=>r;
	
	tts=(x,y)=>{
		x++
		return x+y

	};
	tts=()=>1;  不传参的时候就传个括号
	
	var js = {
		'ee':function(){
			 console.log(this)
			setTimeout(()=>{
				console.log(this) 使用箭头函数时 this会返回setTimeout的作用域（当前作用域） function的话会返回调用这个东西的作用域 window.setTimeout 所以返回window
			},10)
		}
	};
	
	箭头函数匿名函数的写法
	(()=>{
		alert(1);
	})();
	
</script>

31.  ...拓展运算符
<script type="text/javascript">
	
	经常用做传入更多参数使用 hh是个数组 argument不是，无法使用数组的一些操作
	fuck=(x,...hh)=>{
		return hh   
	}		
	console.log(fuck(1,2,3))
	
	var [x,...arr] = [1,2,3]  拓展要放最后面 否则会出错
	
	ab = [1,2,3];
	cd = [4,5,6]
	console.log(...ab);
	console.log([...cd,...ab]);  可以使得数组拼接 当然js也可以
	
	bb = {'a':1,'b':2};
	console.log({...bb}) 显示js要加{}
	
	...总体就是把后的的东西一个一个抽出来

</script>


32.getElement与querySelect区别
通过querySelector是静态获取的，而是用getElementsByClassName是动态获取，也就是说每一次使用都会去对dom节点调用一次。
<script type="text/javascript">
	var cs = document.querySelector('.tt')
	var ls = document.querySelectorAll('.tt li')
	var lss = document.getElementsByClassName('tt')[0].children 
	var nl = document.createElement('li')
	nl.innerText = '777'
	cs.appendChild(nl)
	
	console.log(ls[0].innerText)
	console.log(ls.length)    3  ls为静态 保持刚开始获取的长度
	console.log(lss.length)   4  以为lss是动态获取的 所以长度会跟着改变
	
</script>

33.对象不等性
<script type="text/javascript">
		33.1对象不等性
		var a = new Number(1)
		var b = new Number(1)
		console.log(a==b)
		33.2对象的私有属性   只要是对象就能挂私有属性
		比如数组 jason 这些都是对象

		33.3 new 了都会变成对象
		var str = String("wwww") 注意这个不是对象
		var str2 = new String('www') 这个是

		33.4对象的引用机制
		将对象赋值给一个变量 只会给他的地址
		修改里面的内容也会修改到对象

		但重新给赋值一个对象不会
		var a = [1,2,3]
	    var b = a;
	    b.push(4) 会改变a

	    b = [1,2,3,4] 相当于重新赋值一个新对象 不会改变a
</script>


34.类
<script type="text/javascript">
	34.1js常见类 String Array Number function Object Boolean
	也可以使用new函数创建新的类
	function sad(){};
	new sad();
	34.2原型prototype  是连接类方法的桥梁 里面是这个类的所有方法
	Array.prototype.push = function(){
		alert(1)
		console.log(this) 里面的this 指的是调用这个方法的东西
	}
	可以通过原型修改原有的方法
	34.3添加类的方法

	sad.prototype.ee = function(){
			console.log(2)
		};

	sad.prototype = {
		"aaa":function(){
			 alert(1);
		},
		"bbb":function(){
			 alert(2);
		},
	}
	new sad().aaa();


	prototype 和function位置可以换 

	leo.prototype = {
		b:1
	};
	
	function leo(){
	
	}
	leo.prototype = {
		b:1
	};
	
	
	ff = new leo()
</script>








35.Object是最大的原型 上面的属性会被所有继承
<script type="text/javascript">
	function fuck(){
		
	};
	
	Object.prototype.hh = function(){
		alert(2)
	}
	
	new fuck().hh(A)
</script>


36.获取数据的类 .constructor  获取后可以给类添加方法
<script type="text/javascript">
	var str ='abcd'
	console.log(str.constructor) // ƒ String() { [native code] } 所有他属于的类为String
	console.log(div.constructor)   f HTMLDivElement

	可以获取dom元素的类 来给dom添加方法
	HTMLDivElement.prototype.ate = function(s){
		this.innerText = ''
	}
	div.ate('dwqdqwd')	
</script>

37.this
指向当前对象 在函数里则指向调用这个函数的对象
可以在自定义类中用this挂方法
<script type="text/javascript">
	function aa(){
		this.a = 1;
		this.b = function(){
			console.log(this)  aa {a: 1, b: ƒ}   这里输出都是调用b的aa这对象
		}
		console.log(this)   aa {a: 1, b: ƒ}
	}
	new aa().b()


	var aa = function (){
				console.log(this)
		}
		
	aa()  Window {window: Window, self: Window, document: document, name: "", location: Location, …}
	直接调用则是  window.aa 所以this是window

	new aa()   aa {}  创建对象 则是他自己成了个对象 里面的this指向自己

</script>


38.call  apply 改变this指向
<script type="text/javascript">
		
	var js = {
		aa:function(x,y
		){
			console.log(this,x,y)   Number {4} 1 2
		}
	}
	var a = 4
	
	js.aa.call(a,1,2)

	js.aa.apply(a,[1,2])  apply唯一的区别 只有两个参数 第个参数为数组
	call 的第一个参数会改变this的指向 并转成对象的形式 

</script>

39.原型基础   子类可以用父类的方法 父类不能用子类的
<script type="text/javascript">
	39.1方法1	
	function fu(){
		
	};
	
	function zi(){
		this.b = function(){
			alert('b')
		}
	};
	fu.prototype = {
		'a':function(){
			alert('a')
		}
	};		


	zi.prototype = new fu() zi继承fu
	new zi().a();

	39.2方法2
	function fu(){
		this.a = 12
	};
	
	function zi (){
		fu.call(this)  通过call或者apply继承 相当于到父类走了一遍
	}
	
	console.log(new zi().a)	
</script>

40.随机输
<script>
	var a  = Math.random(); 理论上产生0~1的数 但几乎不可能会出现0和1
	setInterval(function(){
		a  = parseInt(Math.random()*11) ;  所以要生成0~10的数要乘11
		console.log(a)
	},500)
	
</script>




ES6 学习

1.let特性
<script type="text/javascript">
	1.1不能重复声明
	1.2不存在变量提升   var可以在声明之前输出undefined
	1.3块级作用域
	{
		let a=2; 在{}外面无法使用
	}
</script>


2.箭头函数特性
()=>{}

<script type="text/javascript">

2.1 this始终指向函数声明时所在作用域下的this的值
例子：
let showname = ()=>{
	console.log(this.name)
}

var name ='you'
const testa = {
	name:'fuck'
}

showname.call(testa); 结果: you  
无法使用call使得箭头函数的this指向改变

2.2 不能作为构造函数实例化

2.3 不能使用 arguments

2.4 简写
1）当只有一个形参 括号省略
let add = n =>{
	return n + n
}

2) 当代码只有一句 省略花括号 此时return 必须省略
let pow = n=> n*n;


</script>